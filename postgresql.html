<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link href="assets/images/favicon.png" rel="icon" />
    <title>Saibaba | Documentation | Notes</title>
    <meta name="description" content="Learning and Documentation" />
    <meta name="author" content="saibaba.link" />
    <!-- Stylesheet
============================== -->
    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
   
       <!-- Font Awesome Icon -->
       <link rel="stylesheet" type="text/css" href="/assets/vendor/font-awesome/css/all.min.css" />
       <!-- Magnific Popup -->
       <link rel="stylesheet" type="text/css" href="/assets/vendor/magnific-popup/magnific-popup.min.css" />
       <!-- Highlight Syntax -->
       <link rel="stylesheet" type="text/css" href="/assets/vendor/highlight.js/styles/github.css" />

       
    <!-- HIGHLIGHT SQL Syntax-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css" />
    <!-- Custom Stylesheet -->
    <link rel="stylesheet" type="text/css" href="/assets/css/stylesheet.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/postgresql.css" />
  </head>
  <body data-spy="scroll" data-target=".idocs-navigation" data-offset="125">
    <!-- Document Wrapper   
=============================== -->
    <div id="main-wrapper">
      <!-- Header
  ============================ -->
      <header id="header" class="sticky-top">
        <!-- Navbar -->
        <nav class="primary-menu navbar navbar-expand-lg navbar-dropdown-dark">
          <div class="container-fluid">


                       <!-- Sidebar Toggler -->
                       <button id="sidebarCollapse" class="navbar-toggler d-block d-md-none" type="button">
                        <span>.</span>
                        <span class="w-75"></span>
                        <span class="w-50"></span>
                      </button>
  
                      

             <a rel='noopener' class="logo ml-md-3" href="index.html" title="Learning and Documentation">
              <img src="assets/images/learning_documentation.png" alt="Learning and Documentation" />
            </a>

            <span class="text-2 ml-2">v1.0</span>
            <!-- Logo End -->
            <!-- Navbar Toggler -->
           <button class="navbar-toggler ml-auto" type="button" data-toggle="collapse" data-target="#header-nav">.</button>


            <div id="header-nav" class="collapse navbar-collapse justify-content-end">
              <ul class="navbar-nav">
                <li class="dropdown">
                   <a rel='noopener' class="dropdown-toggle" href="#">Additional Resources</a>
                  <ul class="dropdown-menu">
                    <li>
                      <a target="_blank" rel='noopener' class="dropdown-item" href="https://www.postgresqltutorial.com/">Postgresql-Tutorial</a>
                    </li>
                    <li class="dropdown">
                       <a rel='noopener' class="dropdown-item dropdown-toggle" href="#">Dropdown Action</a>
                      <ul class="dropdown-menu">
                        <li>
                           <a rel='noopener' class="dropdown-item" href="index.html">Action</a>
                        </li>
                        <li>
                           <a rel='noopener' class="dropdown-item" href="feature-header-dark.html">Another Action</a>
                        </li>
                        <li>
                           <a rel='noopener' class="dropdown-item" href="feature-header-primary.html">Something Else Here</a>
                        </li>
                        <li>
                           <a rel='noopener' class="dropdown-item" href="index-2.html">Another Link</a>
                        </li>
                      </ul>
                    </li>
                    <li>
                       <a rel='noopener' class="dropdown-item" href="#">Another Action</a>
                    </li>
                    <li>
                       <a rel='noopener' class="dropdown-item" href="#">Something Else Here</a>
                    </li>
                  </ul>
                </li>
                <li class="dropdown">
                   <a rel='noopener' class="dropdown-toggle" href="#">Online Tools</a>
                  <ul class="dropdown-menu">
                    <li>
                      <a target="_blank" rel='noopener' class="dropdown-item" href="https://pg-sql.com/"> pg-sql</a>
                    </li>
                    <li>
                       <a rel='noopener' class="dropdown-item" href="https://tcsglobal.udemy.com/course/sql-and-postgresql/learn/lecture/22800079#overview"> Course</a>
                    </li>
                    <li>
                       <a rel='noopener' class="dropdown-item" href="https://www.diffchecker.com/"> Difference Checker</a>
                    </li>
                    <li>
                       <a rel='noopener' class="dropdown-item" href="https://discord.com/channels/797239171730505839/797239171730505842"> Discord Channel</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a target="_blank" rel='noopener' href="https://themeforest.net/user/harnishdesign/#contact?ref=HarnishDesign">Support</a>
                </li>
                <span id="searching">
                <form class="form-inline">
                      <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search"
                        id="search-input">
                  </form>
                </span>
              </ul>
            </div>
          </div>
        </nav>
        <!-- Navbar End -->
      </header>
      <!-- Header End -->
     
      <div id="search-content"><!-- SEARCHABLE CONTENT START -->
         <!-- Content   ============================ -->
      <div id="content" role="main">
        <!-- Sidebar Navigation 	============================ -->
        <div class="idocs-navigation bg-light">
          <ul class="nav flex-column">
            <li class="nav-item">
               <a rel='noopener' class="nav-link active" href="#idocs_start">Getting Started</a>
              <ul class="nav flex-column">
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_choose_database">Choosing the Database</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_html_structure">Joins</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_sass">Aggregate Functions</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_color_schemes">Sorting</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_theme_customization">Operators</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_logo_settings">Logo Settings</a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_layout">Sub Queries</a>
              <ul class="nav flex-column">
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_header">Header</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_navbar">Navbar</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_sidebar">Sidebar</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_footer">Footer</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_box_layout">Box Layout</a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_content">Data Types</a>
              <ul class="nav flex-column">
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_typography">Typography</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_code">Code</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_table">Table</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_icons">Icons</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_image">Image</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_video">Video</a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_performance">Performance</a>
              <ul class="nav flex-column">
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_perf_basics">Basics</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_heap_file">Heap File</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_indexes">Indexes</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_perf_add_details">Additional Details</a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_query_tuning">Query Tuning</a>
              <ul class="nav flex-column">
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_qt_basics">Basics</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_qt_advanced">Advanced</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_qt_add_details">Additional Details</a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_regex">Regular Expressions </a>
              <ul class="nav flex-column">
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_regex-basics">Basics </a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_quantifiers">Quantifiers </a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_meta_character">Meta Characters</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_special_chars">Special Characters </a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_zerowidth_assert">Zero-Width Assertions </a>
                </li>

                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_capturing_groups">Capturing Groups </a>
                </li>

                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_regex_matches">regexp_matches function </a>
                </li>
  
                
                
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#idocs_regex_examples">Examples </a>
                </li>
              </ul>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_faq">FAQ</a>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_source_credits">Source & Credits</a>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_support">Support</a>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_templates">More Templates</a>
            </li>
            <li class="nav-item">
               <a rel='noopener' class="nav-link" href="#idocs_changelog">Changelog</a>
              <ul class="nav flex-column">
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#v1-1">v1.1</a>
                </li>
                <li class="nav-item">
                   <a rel='noopener' class="nav-link" href="#v1-0">v1.0</a>
                </li>
              </ul>
            </li>
          </ul>
        </div>
        <!-- Docs Content	============================ -->

        <div class="idocs-content">
          <div class="container-fluid">
            <!-- Getting Started 	============================ -->
            <section id="idocs_start">
              <h1>PostgreSQL</h1>
              <h2>Learning and Documentation</h2>
              <p class="lead">Lets gets started!!</p>
              <hr />
              <div class="row">
                <div class="col-sm-6 col-lg-4">
                  <ul class="list-unstyled">
                    <li>
                      <strong>Version:</strong> 1.0
                    </li>
                    <li>
                      <strong>Author:</strong>
                      <a rel='noopener' href="https://devops-cloud-lrn.github.io/" target="_blank">Learning and Documentation</a>
                    </li>
                  </ul>
                </div>
                <div class="col-sm-6 col-lg-4">
                  <ul class="list-unstyled">
                    <li>
                      <strong class="font-weight-700">Created:</strong> 3 January, 2023
                    </li>
                    <li>
                      <strong>Update:</strong> 3 January, 2023
                    </li>
                  </ul>
                </div>
              </div>
             <p class="alert alert-info"> If you have any questions that are beyond the scope of this help file, Please feel free to email via <a target="_blank" rel='noopener' href="#">Item Support Page</a>. </p>
            </section>
            <hr class="divider" />
            <!-- CHOOSING THE DATABASE START		============================ -->
            <section id="idocs_choose_database">
              <h3>Choosing the Right Database </h3>
              <p class="question"  map="sb01"> What questions to be asked before choosing the database? </p>
              <p class="answer"  map="sb01">
                1. What is the workload? Is it read-heavy, write-heavy or balanced workload ? <br/>
                2. What are the Throughput needs? And will it  change? Does it need to scale or fluctuate during the day?<br/>
                3. How much data to store and for how long? Will it grow? Average object size? How are they accessed? <br/>
                4. Data durability? Source of truth for the data ? <br/>
                5. What are the Latency requirements? How many concurrent users for the database ? <br/>
                6. What is the data model ? Structured ? Semi-Structured? How will you query the data ?  <br/>
                7. What is the Nature of the Schema? Strong schema? More flexibility? Reporting? Search? RDBMS/ NoSQL <br/>
                8. What are the License costs?  <br/>
              </p> <br/>

           <!-- TWO 		============================ -->
              <p class="question" map="sb02"> What are the purpose built databases in AWS? </p>
              <p class="answer"  map="sb02">
                <img  map="sb02" class="img-fluid w-100 w-sm-50 w-md-75"  src="assets/images/postgresql/purpose-built-db.JPG" alt="Purpose built databases" />
                
              </p>

               <!-- THREE 		============================ -->
              <p class="question"  map="sb03"> What are the different types of data? </p>
              <p class="answer"  map="sb03">
                There are three types of data <br/>
                1. <b>Structured</b>: 
                  <ul>
                    <li>Organized data and Strict, Schema compliant, predefined structure. Typically stored in tables.(Relational databases) <br/> </li>
                    <li>Suitable for OLTP (Online Transactional Processing ) and OLAP (Online Analytical Processing) <br/> </li>
                  </ul>
                    
                2. <b>Semi-Structured </b>
                <ul>
                  <li>Organized data and not strict, i.e. not constrained by a specific Schema. Or easily expandable schema. <br/> </li>
                  <li>Examples include XML , JSON, Parquet etc. Typically considered as non relational databases <br/> </li>
                  <li>Typically used in Big-data solutions that demands low latency and high performance. <br/> </li>
                </ul>

                3. <b>Unstructured </b>
                <ul>
                  <li>Fully un-organized. Any data that doesn't fall under structured or semi-structured is unstructured.  <br/> </li>
                  <li>Examples include Files, documents, images, photos, videos,  messages , social media posts  etc. <br/> </li>
                </ul>

              </p>
          
               <!-- FOUR 		============================ -->
               <p class="question" map="sb04"> Comparison of Relational and Non-Relational Databases </p>
               <p class="answer"  map="sb04">
                 <img  map="sb02" class="img-fluid w-100 w-sm-50 w-md-75"  src="assets/images/postgresql/sql-nosql-compare.png" alt="SQL vs NoSQL" />
                 
               </p>
              
            </section>
             <!-- CHOOSING THE DATABASE END		============================ -->
            <hr class="divider" />
           

            <!-- HTML Structure 		============================ -->
            <section id="idocs_html_structure">
              <h2>HTML Structure</h2>
              <p> iDocs follows a simple and easy to customize coding structure. Here is the sample for your reference: <br /> The template is based on 
                 <a rel='noopener' class="ml-1" target="_blank" href="https://getbootstrap.com/">
                  <i class="fas fa-external-link-alt"></i> Bootstrap Framework </a>
              </p>
              <p class="alert alert-info"> If you need more information, please visit bootstrap site: <a target="_blank" rel='noopener' href="https://getbootstrap.com/docs/4.4/layout/grid/">https://getbootstrap.com</a>
              </p>
            </section>
            <hr class="divider" />
            <!-- Sass		============================ -->
            <section id="idocs_sass">
              <h2>Sass</h2>
            </section>
            <hr class="divider" />
            <!-- Color Schemes 		============================ -->
            <section id="idocs_color_schemes">
              <h2>Color Schemes</h2>

            </section>
            <hr class="divider" />
            <!-- Customization 		============================ -->
            <section id="idocs_theme_customization">
              <h2>Theme Customization</h2>
            </section>
            <hr class="divider" />
            <!-- Logo Settings 		============================ -->
            <section id="idocs_logo_settings">
              <h2>Logo Settings</h2>
            </section>
            <hr class="divider" />
            <!-- Layout 		============================ -->
            <section id="idocs_layout">
              <h2>Layout</h2>
              <p class="lead mb-5"> Documentation and examples for header, navbar, sidebar, footer </p>
            </section>
            <!-- Header 		============================ -->
            <section id="idocs_header">
              <h2>Header</h2>
            </section>
            <hr class="divider" />
            <!-- Navbar 		============================ -->
            <section id="idocs_navbar">
              <h2>Navbar</h2>
            </section>
            <hr class="divider" />
            <!-- Sidebar 		============================ -->
            <section id="idocs_sidebar">
              <h2>Sidebar</h2>
              <h4>Light Sidebar:</h4>
              <h4>Dark Sidebar:</h4>
              
            </section>
            <hr class="divider" />
            <!-- Footer ============================ -->
            <section id="idocs_footer">
              <h2>Footer</h2>
            </section>
            <hr class="divider" />
            <!-- Box Layout Style 		============================ -->
            <section id="idocs_box_layout">
              <h2>Box Layout Style</h2>
            </section>
            <hr class="divider" />
            <!-- Content 		============================ -->
            <section id="idocs_content">
              <h2>Content</h2>
              <p class="lead mb-5"> Documentation and examples for displaying typography, code, table, image and video and more.. </p>
            </section>
            <!-- Typography 		============================ -->
            <section id="idocs_typography">
              <h2>Typography</h2>
              <p class="text-4"> Documentation and examples for typography, headings, body text, lists, and more. </p>
              <h3>Headings</h3>
            </section>
            <hr class="divider" />
            <!-- Code	============================ -->
            <section id="idocs_code">
              <h2>Code</h2>
              <p class="text-4"> Documentation and examples for displaying inline and multiline blocks of code </p>
              <h3 class="mt-5">Inline code</h3>
            </section>
            <hr class="divider" />
            <!-- Table	============================ -->
            <section id="idocs_table">
              <h2>Table</h2>
              <p class="text-4"> Documentation and examples for opt-in styling of tables. </p>
            </section>
            <hr class="divider" />
            <!-- Icons 		============================ -->
            <section id="idocs_icons">
              <h2>Icons</h2>
            </section>
            <hr class="divider" />
            <!-- Image 		============================ -->
            <section id="idocs_image">
              <h2>Image</h2>
              <p class="text-4"> Documentation and examples for opting images into responsive behavior and add lightweight styles to them—all via classes. </p>
              <h3 class="mt-5">Responsive Images</h3>
              <h3 class="mt-5">Image lightbox</h3>
              <p>Show image popup when click on image:</p>
            </section>
            <hr class="divider" />
            <!-- Video ============================ -->
            <section id="idocs_video">
              <h2>Video</h2>
              <p class="text-4"> Create responsive video embeds based on the width of the parent by creating an intrinsic ratio that scales on any device. </p>
              <h3 class="mt-5">Embedded Video</h3>
              <p> Wrap any embed like an <code>&lt;iframe&gt;</code> in a parent element with <code>.embed-responsive</code> and an aspect ratio. The <code>.embed-responsive-item</code> isn’t strictly required, but we encourage it. </p>
              <div class="embed-responsive embed-responsive-16by9">
                <!-- <iframe class="embed-responsive-item" src="https://www.youtube.com/embed/7e90gBu4pas" allowfullscreen></iframe> -->
                <iframe class="embed-responsive-item"  src="https://www.youtube.com/embed/85pG_pDkITY" title="Posgresql" allowfullscreen></iframe>
                
              </div>
            </section>
            <hr class="divider" />
            <section id="idocs_performance">
              <h2>Postgres Performance</h2>
              <p class="lead mb-5"> Documentation and examples for PostgreSQL Performance, Heap File, Blocks and Indexes </p>
            </section>
            <hr class="divider" />
            <!-- PERFORMANCE BASICS  ============================ -->
            <section id="idocs_perf_basics">
              <h4>Basics</h4>
              <div>
                <ol>
                  <li>
                    <p class="question">Where does Postgres Store Data?</p>
                    <pre>
												<code class="hljs" data-language="sql"> SHOW data_directory; </code>
											</pre>
                    <p class="answer"> This retrieves the path where data directory is installed for that postgresql. In the 'base' folder under data directory all the databases will be stored/persisted. Each database will be stored as a folder and an integer is given as the folder name. </p>
                  </li>
                  <li>
                    <p class="question"> How to know what database is mapped to the folder name? </p>
                    <p class="answer"> The folder name will be a number not the actual database name. </p>
                    <pre>
												<code class="hljs" data-language="sql">SELECT oid, datname from pg_database;</code>
											</pre>
                  </li>
                  <li>
                    <p class="question"> What are the contents of the database folder? </p>
                    <p class="answer"> For example, postgres database folder. Here postgres database folder will be mapped to a integer number. When you go into that folder, you would see a lot of files. To know more details about that folder, Run the query </p>
                    <pre>
												<code class="hljs" data-language="sql">SELECT * FROM pg_class;</code>
											</pre>
                    <p class="answer"> This will show all the details of all the databases created under the installed Postgresql </p>
                  </li>
                </ol>
              </div>
            </section>
            <hr class="divider" />
            <!-- PERFORMANCE HEAP FILE 	============================ -->
            <section id="idocs_heap_file">
              <h4>HEAPS, PAGES/BLOCKS & TUPLES</h4>
              <div>
                <ol>
                  <li>
                    <p class="question">What is a HEAP or HEAP File?</p>
                    <p class="answer"> HEAP/HEAP File contains all the information for a specific relation/table. It holds all the data for a particular table. Ex: if we have created a table called EMPLOYEES, a HEAP File gets created to store all the Employees information. This file will be stored under '"data_directory"/base/oid_folder_of_the_database/oid_of_the_table' Note: This is not HEAP Data structure </p>
                  </li>
                  <li>
                    <p class="question">What is a Tuple or Item?</p>
                    <p class="answer"> It is nothing but a particular row of a table. [Individual row from the table]. </p>
                  </li>
                  <li>
                    <p class="question">What is Block or Page?</p>
                    <p class="answer"> The Heap file is divided into many different 'Blocks' or 'Pages'. Each Page/Block stores multiple number of rows Each Block/Page is 8 KB in size. </p>
                  </li>
                  <li>
                    <p class="question">How BLOCK is managed/stored ?</p>
                    <p class="answer"> Each Block would have 5 sections <br /> 1. Page Header Data (Information about the block) -24 bytes long <br /> 2. Item Id Data (Information about the Tuples) - 4 bytes per item. <br /> 3. Free Space: The unallocated space. New item identifiers are allocated from the start of this area, new items from the end. <br /> 4. Items (Data of the Tuples) <br /> 5. Special Space (Index access method specific data. Different methods store different data. Empty in ordinary files) <br /> 6. To know how PostgreSQL stores data at the binary level check this <a rel='noopener' href="https://www.postgresql.org/docs/current/storage-page-layout.html">Link</a>
                    </p>
                  </li>
                </ol>
              </div>
            </section>
            <hr class="divider" />
            <!-- PERFORMANCE INDEXES		============================ -->
            <section id="idocs_indexes">
              <h4>Indexes</h4>
              <div>
                <ol>
                  <li>
                    <p class="question">What is a Full Table Scan?</p>
                    <p class="answer"> If there is no Index created, before applying the filters all the data from the Heap File will be loaded RAM. The search takes place one by one. As a result it would impact the Performance. The primary objective is to make sure the data transfer between hard-disk and RAM is minimized. Try ways to limit the data transfer. In general, the Full table scan results into a poor performance. But there are situations where Full Table Scan is desirable. </p>
                  </li>
                  <li>
                    <p class="question">What is an Index?</p>
                    <p class="answer"> Index is a data structure that efficiently tells us what block/index a record is stored. When Index is created, a separate mapping file is build to store the address of each value. 1. A file containing column value and it address gets created <br /> 2. Based on the Index Type, the elements will be organized/stored in a meaningful way. [Alphabetical for text and values for numbers] <br /> 3. For example, B-Tree Index Type, all the values will be sorted organized into a tree by applying B-Tree. <br /> 4. All the values will be distributed in the leaf-nodes evenly in order left to right. <br />
                    </p>
                  </li>
                  <li>
                    <p class="question">How to create/delete an Index?</p>
                    <span class="answer"> When the Index name is not provided
                      <pre>
													<code class="hljs" data-language="sql">CREATE INDEX ON 'table-name' ('column-name')</code>
												</pre> Generally tablename_columnname_idx is the convention being followed. To create Index with a predefined name
                      <pre>
													<code class="hljs" data-language="sql">CREATE INDEX 'index-name' ON 'table-name' ('column-name')</code>
												</pre>
                      <pre>To drop an Index
													<code class="hljs" data-language="sql"> DROP INDEX 'index-name'</code>
												</pre>
                    </span>
                  </li>
                  <li>
                    <p class="question">What are the benefits of Indexes?</p>
                    <p class="answer"> In general,We will get the tremendous benefits by creating Indexes. <br />
                      <b>Improved query performance: </b> Indexes allow the database to quickly locate and retrieve specific rows of data, which can greatly improve the performance of queries that search for specific data. <br />
                      <b>Reduced disk I/O:</b> Without indexes, the database would need to scan the entire table to find the desired data, which can be slow and resource-intensive. Indexes allow the database to quickly locate the desired data, reducing the amount of disk I/O required. <br />
                      <b>Improved concurrency: </b>Indexes can improve the concurrency of a database by reducing the amount of time that a table lock is held. <br />
                      <b>Enforced uniqueness: </b>Some indexes, such as unique indexes, can be used to enforce uniqueness constraints on the data. <br />
                      <b>Improved join performance: </b>Indexes can also improve the performance of joins, by reducing the amount of data that needs to be scanned when joining tables. <br />
                      <b>Improved performance for aggregate functions: </b>Certain types of indexes, such as B-tree, can be used to improve the performance of aggregate functions such as SUM, COUNT, AVG, etc. <br />
                      <b>Improved performance for sorting: </b>Indexes can be used to sort the data, which can improve the performance of ORDER BY clauses. <br />
                    </p>
                  </li>
                  <li>
                    <p class="question"> What are the downsides of creating Indexes? </p>
                    <p class="answer">
                      <b>Increased disk space usage:</b> Indexes require additional disk space to store the index data. This can be a significant issue for large tables or for systems with limited disk space. <br />
                      <b>Increased write performance: </b> time a row is inserted, updated, or deleted in a table, the corresponding index must also be updated. This can slow down write performance, especially for large tables or high write loads. <br />
                      <b>Increased maintenance overhead:</b> Indexes need to be maintained, which can add additional overhead. This includes tasks such as updating the index when data is added or removed, and periodically rebuilding the index to improve performance. <br />
                      <b>Query performance trade-offs: </b> Indexes can improve query performance for certain types of queries, but they may not be beneficial for all queries. Additionally, using too many indexes can actually slow down certain types of queries. <br />
                      <b>Index bloat: </b> Over time, indexes can become fragmented, which can cause them to take up more disk space and slow down performance. Regularly monitoring and vacuuming the indexes can help prevent this issue. <br />
                      <b>un-used Indexes: </b> In certain scenarios, Postgres doesn't use indexes while executing queries. We need to be aware and create them only when they are needed. <br />
                    </p>
                  </li>
                  <li>
                    <p class="question">What is Index Fragmentation?</p>
                    <p class="answer"></p>
                  </li>
                  <li>
                    <p class="question"> When do we need to rebuild Indexes periodically in Postgres? </p>
                    <p class="answer"></p>
                  </li>
                  <li>
                    <p class="question"> How to get the table size and index size? </p>
                    <div class="answer">
                      <pre>
													<code class="hljs" data-language="sql">
                              SELECT pg_size_pretty(pg_relation_size('table_name'))
                              SELECT pg_size_pretty(pg_relation_size('index_name'))
                            </code>
												</pre>
                    </div>
                  </li>
                  <li>
                    <p class="question"> What are the different types of Indexes? </p>
                    <p class="answer">
                      <b> B-Tree (Balanced Tree Index):</b> A B-Tree index is a type of index that is commonly used in relational databases, including PostgreSQL. B-Tree stands for balanced tree, which refers to the way the index is structured. It is a general purpose index. 99% of the time you want this. In a B-Tree index, the data is organized into a hierarchical structure of nodes and keys. Each node in the tree contains a collection of keys, which are used to navigate to the next level of the tree. The keys in each node are sorted in ascending order, which allows for efficient search, insertion, and deletion operations. When a query is executed that requires data from a B-Tree indexed table, the database uses the keys in the B-Tree index to quickly locate the desired data. This allows the database to avoid scanning the entire table, which can greatly improve the performance of the query. B-Tree indexes are particularly useful for large datasets, and are well suited for queries that involve range searches, such as WHERE id BETWEEN 100 AND 200. They also support sorting and aggregate functions such as SUM, COUNT, AVG etc. Additionally, B-Tree indexes are multi-purpose indexes and can be used for many types of queries, including single-column and multi-column queries, and for enforcing unique constraints on the indexed columns. <br />
                      <b>2. Hash Index: </b> It used to speed up simple equality checks. A HASH index is a type of index in PostgreSQL that uses a hash function to map the indexed values to a fixed number of buckets. It is useful for exact-match lookups of a single column, particularly when the cardinality of the indexed column is not too high, and the data distribution is random. HASH indexes are created using the CREATE INDEX command with the USING HASH option.
                    </p>
                    <pre> The syntax would be:
  
												<code class="hljs" data-language="sql">  CREATE INDEX index_name ON table_name (column_name) USING HASH;  </code>
											</pre>
                    <p class="answer"> HASH indexes are useful for: <br />
                      <b>Exact-match lookups:</b> HASH indexes are particularly efficient for exact-match lookups on a single column. They can quickly locate the desired data by hashing the indexed value and looking up the corresponding bucket. <br />
                      <b>High-cardinality data:</b> HASH indexes are useful for high-cardinality data, which means data with a large number of distinct values, as it can handle a large number of unique values. <br />
                      <b>Random data distribution:</b> HASH indexes are most efficient when the data distribution is random. <br />
                      <b>Equality operator:</b> HASH indexes are most efficient when used with the equality operator (=) <br /> However, HASH indexes have some drawbacks, such as they are not useful for range queries and they can be slower than other types of indexes when the data distribution is not random, or when the table has a high number of duplicates values. Additionally, they can not be used for sorting or aggregate functions such as SUM, COUNT, AVG etc. It's worth noting that PostgreSQL only creates an index when it determines that the index will be useful and beneficial for the performance of the queries, and it's always recommended to monitor the performance of the queries and indexes to ensure that they are working as expected.
                    </p>
                    <br />
                    <p class="question"> 2.1 What is the cardinality of the indexed column? </p>
                    <p class="answer"> The cardinality of an indexed column refers to the number of distinct values in that column. The cardinality of a column can have an impact on the performance of a HASH index. When the cardinality of the indexed column is low, it means that there are relatively few distinct values in the column. In this case, a HASH index may not be as efficient as other types of indexes, such as a B-Tree index </p>
                    <div class="answer">
                      <b>3. GiST Index: </b> It is used for Geometry, full-text search. <br /> 
                      <u>GiST (Generalized Search Tree) index</u> is a type of index in PostgreSQL that is used for efficient search on complex data types and operators. 
                      It's a multi-purpose index that can be used for several types of data, such as geometric data, IP addresses, full-text search and more. 
                      GiST indexes are created using the CREATE INDEX command with the USING option and the gist method. 
                      
                      The syntax would be 
                      <pre>
                        <code class="hljs" data-language="sql"> CREATE INDEX index_name ON table_name USING GIST(column_name);     </code>
                      </pre>
                       <u>GiST indexes are useful for: </u>> <br/>
                       <b>Complex data types: </b>GiST indexes are designed for efficient search on complex data types and operators that cannot be indexed by B-tree or Hash indexes. 
                       It can be used for spatial data, IP addresses, full-text search, and more. <br/>
                       <b>Range queries: </b> GiST indexes are efficient for range queries, such as  <code class="hljs" data-language="sql">SELECT ... WHERE column_name > x AND column_name <  y. </code> <br/>
                        <b>Spatial data: </b> GiST indexes are particularly useful for spatial data and spatial queries, 
                        <code class="hljs" data-language="sql">such as SELECT ... WHERE ST_Contains(column_name, x) </code> <br/>
                         <b> Text search:</b> GiST indexes can be used to improve the performance of full-text search queries <br/>
                          However, GiST indexes have some limitations, such as they can be slower than other types of indexes when the data distribution is not random, they can't be used for sorting, and they can have high maintenance overhead.
                           It's worth noting that PostgreSQL only creates an index when it determines that the index will be useful and beneficial for the performance of the queries, and it's always recommended to monitor the performance of the queries 
                           and indexes to ensure that they are working as expected. <br/><br/>
                           
                        <div class="answer">  
                          <b> 4. SP-GiST Index: </b> It is used for clustered data, such as dates - many rows might have the same year. <br/>
                          <u>SP-GiST (Space-Partitioned Generalized Search Tree)</u>: index is a type of index in PostgreSQL that is similar to the GiST index, but it is designed for data that can be partitioned in a space-efficient way, 
                          such as IP addresses, geometric data, and more. 
                          SP-GiST indexes are created using the CREATE INDEX command with the USING option and the spgist method. <br/>
                          The syntax would be 
                          <pre>
                            <code class="hljs" data-language="sql"> CREATE INDEX index_name ON table_name USING SPGIST(column_name);</code>
                          </pre>
                          <u>SP-GiST indexes are useful for: </u><br/>
                            <b>Complex data types: </b>SP-GiST indexes are designed for efficient search on complex data types that can be partitioned in a space-efficient way, such as IP addresses, geometric data, and more. <br/>
                            <b>Range queries: </b> SP-GiST indexes are efficient for range queries, such as 
                            <code class="hljs" data-language="sql">  SELECT ... WHERE column_name> x AND column_name < y. </code>
                            <b>Spatial data: </b> SP-GiST indexes are particularly useful for spatial data and spatial queries, such as 
                            <code class="hljs" data-language="sql"> SELECT ... WHERE ST_Contains(column_name, x)  </code>
                            <b>Text search:</b> SP-GiST indexes can be used to improve the performance of full-text search queries Data that can be partitioned in a space-efficient way : 
                            SP-GiST indexes are particularly useful for data that can be partitioned in a space-efficient way, as they can handle high-cardinality data and random data distribution. 
                            However, SP-GiST indexes have some limitations, such as they can be slower than other types of indexes when the data distribution is not random, they can't be used for sorting, 
                            and they can have high maintenance overhead. It's worth noting that PostgreSQL only creates an index when it determines that the index will be useful and beneficial for the performance of the queries, 
                            and it's always recommended to monitor the performance of the queries and indexes to ensure that they are working as expected. <br/>
                          </div>
                        <div class="answer">
                           <b> 5. GIN Index: </b> For columns that contain arrays or JSON data GIN (Generalized Inverted Index) is a type of index in PostgreSQL that is used for efficient search on data with multiple values per row, 
                           such as arrays, full-text search, and hstore data type. It's a multi-purpose index that can be used for several types of data, such as text search, IP addresses and more. 
                           GIN indexes are created using the CREATE INDEX command with the USING GIN option. <br/>
                           The syntax would be 

                           <pre>
                            <code class="hljs" data-language="sql"> CREATE INDEX index_name ON table_name USING GIN(column_name);</code>
                          </pre>

                          <u>GIN indexes are useful for: </u><br/>
                          <b>Data with multiple values per row: </b>GIN indexes are particularly efficient for data with multiple values per row, such as arrays, full-text search, and hstore data type. <br/>
                          <b>Text search: </b> GIN indexes are commonly used for full-text search and other text search-related queries. <br/>
                          <b>Efficient search:</b> GIN indexes are efficient for search queries, such as SELECT ... WHERE column_name @> x  <br/>
                          <b>High-cardinality data: </b>GIN indexes are useful for high-cardinality data, which means data with a large number of distinct values, as it can handle a large number of unique values Data with complex data types: 
                          GIN indexes can be used for data with complex data types that cannot be indexed by B-tree or Hash indexes. <br/>
                          However, GIN indexes have some limitations, such as they can be slower than other types of indexes when the data distribution is not random, they can't be used for sorting, 
                          and they can have high maintenance overhead. It's worth noting that PostgreSQL only creates an index when it determines that the index will be useful and beneficial for the performance of the queries, 
                          and it's always recommended to monitor the performance of the queries and indexes to ensure that they are working as expected. 
                          <br/>
                          <div class="question">
                          5.1 How GIN Index is best for JSON data ? 
                          </div>
                          <div class="answer"></div>

                          <div class="answer">
                          <b>6. BRIN Index: </b> It is used and specialized for really large datasets. 
                          <u>BRIN (Block Range INdex) </u> is a type of index in PostgreSQL that is used for large-scale data with a sortable order, such as time-series data or data that is sorted by an integer or a timestamp column. 
                          It's particularly useful for tables that have millions or billions of rows, where a traditional B-tree index would not be efficient. 
                          BRIN indexes are created using the CREATE INDEX command with the USING option and the brin method. <br/>
                          The syntax would be 

                          <pre>
                            <code class="hljs" data-language="sql"> CREATE INDEX index_name ON table_name USING BRIN (column_name);</code>
                          </pre>
                           
                         <u> BRIN indexes are useful for:</u> 
                         <b>Large-scale data: </b>
                         BRIN indexes are particularly useful for large-scale data with a sortable order, such as time-series data or data that is sorted by an integer or a timestamp column. <br/>
                         <b>Range queries: </b> BRIN indexes are efficient for range queries, such as 
                         <code class="hljs" data-language="sql"> SELECT ... WHERE column_name > x AND column_name < y.  </code> 
                         <b>Time-series data:</b> BRIN indexes are particularly useful for time-series data, as they can handle data with a large number of rows and provide efficient queries on range of timestamps. <br/>
                         <b>Data sorted by an integer or a timestamp column:</b> BRIN indexes can handle data sorted by an integer or a timestamp column, which means that the indexed column has a sortable order. <br/>
                         <b> Large-scale tables:</b> BRIN indexes are particularly useful for large-scale tables, where a traditional B-tree index would not be efficient.
                          However, BRIN indexes have some limitations, such as they are not useful for data that is not sorted by an integer or a timestamp column, they can't be used for sorting, and they can have high maintenance overhead. 
                          It's worth noting that PostgreSQL only creates an index when it determines that the index will be useful and beneficial for the performance of the queries, and 
                          it's always recommended to monitor the performance of the queries and indexes to ensure that they are working as expected. </div>
                        <!-- </div> -->
                        </div>
                  </li>
                  <li>
                    <p class="question"> what is the difference between GiST Index and SP-GiST Index? </p>
                    <p class="answer"></p>
                  </li>
                  <li>
                    <p class="question"> When does POSTGRES automatically creates Indexes? </p>
                    <p class="answer"> Primary keys: When a primary key constraint is created on a table, PostgreSQL automatically creates a unique index on the primary key column(s). Foreign keys: When a foreign key constraint is created on a table, PostgreSQL automatically creates an index on the foreign key column(s). Unique constraints: When a unique constraint is created on a table, PostgreSQL automatically creates a unique index on the constrained column(s). Full-text search: When a text search index is created using the full-text search functionality in PostgreSQL, the database will automatically create an index on the specified text search column(s) Expressions index: When an expression index is created, PostgreSQL creates an index on the result of the specified expression. GIN (Generalized Inverted Index): When a GIN index is created, PostgreSQL automatically creates an index on the specified column(s) It's worth noting that PostgreSQL only creates an index when it determines that the index will be useful and beneficial for the performance of the queries. And it's always recommended to monitor the performance of the queries and indexes to ensure that they are working as expected. </p>
                  </li>
                  <li>
                    <p class="question"> How to see automatically generated indexes? </p>
                    <p class="answer"> In general, these indexes do not appear in the constraints section in PG-Admin To pull all the indexes we need to pull it form pg_class table SELECT relname, relkind FROM pg_class WHERE relkind = 'i' The pg_class table lists all the objects that exists in the database. In the above 'i' refers to Index. </p>
                  </li>
                  <li>
                    <p class="question"> When do we need to create Full-text search index? </p>
                    <p class="answer"></p>
                  </li>
                  <li>
                    <p class="question"> When do we need to create Expression Index? </p>
                    <p class="answer"></p>
                  </li>
                  <li>
                    <p class="question">When do we need to create GIN Index?</p>
                    <p class="answer"></p>
                  </li>
                  <li>
                    <p class="question">What happens when Index is created?</p>
                    <p class="answer"> A file gets created on the disk for the created index with a random number When you create an index in PostgreSQL, a new data structure is created that stores a copy of one or more columns of data from a table, along with a pointer to the original data. This new data structure is organized in a way that allows for faster searching, sorting, and filtering of the data based on the indexed columns. The structure of the file internally has the following 1. 8KB Meta Page 2. 8KB Leaf Block/Page 3. 8KB Leaf Block/Page 4. 8KB Root Block/Page 5. 8KB Leaf Block/Page etc. In Memory Meta Page --> Root Block/Page --> one or more Leaf Block/Page 
                      <img src="assets/images/postgresql/index-in-memory.JPG" alt="Index in memory" />
                    </p>
                  </li>
                  <li>
                    <p class="question">What is pageinspect extension?</p>
                    <p class="answer"> The extension provides additional functionality in the postgresql 
                      The pageinspect extension would help to provide information or inpsect about pages/blocks or Heap File. <br/>
                      
                      Syntax: 
                      <pre>
                        <code class="hljs" data-language="sql"> 
                          CREATE EXTENSION pageinspect; 
                          SELECT * FROM bt_metap('index_name')
                        </code>
                      </pre>
                      
                       Getting the information in the index Heap File 
                       
                       <pre>
                        <code class="hljs" data-language="sql">SELECT * FROM bt_page_items('index_name') </code>
                      </pre>
  

                       Getting the information in the specific page of a index heap file 
                       
                       <pre>
                        <code class="hljs" data-language="sql">
                          SELECT * FROM bt_page_items('index-name', page_number) 
                          Example: SELECT * FROM bt_page_items('user_username_idex', 1)
                       </code>
                      </pre>
                      Some of the columns such as ctid will also be available in the user created tables. 
                      They will be hidden. We can use them in the query. The ctid will be a combination of two (page-number, index-number) if we use the page_number =3 which is a Root Node/page. 
                      Here ctid represents the pagenumber and index of the index heap file. 
                      Here the index would mostly be <br/>
                      1. for any other page number which is a Leaf(or Parent) Page/Block.  Here ctid represents the pagenumber and index of the table heap file. 
                      Every Leaf Page/Blocks first entry would have a pointer to the next page/block. 
                    </p>
                 </li>

                 <li>
                  <p class="question"> Another Question? </p>
                  <p class="answer"></p>
                 </li>


                </ol>
              </div>
            </section>
            <hr class="divider" />
            <!-- PERFORMANCE ADDITIONAL DETAILS ============================ -->
            <section id="idocs_perf_add_details">
              <h4>Additional Details</h4>
            </section>
            <hr class="divider" />
            <!-- QUERY TUNING  	============================ -->
            <section id="idocs_query_tuning">
              <h2>Query Tuning</h2>
              <p class="lead mb-5"> Documentation and examples for PostgreSQL Basic and Advanced Query Tuning, EXPLAIN and EXPLAIN ANALYZE </p>
            </section>
            <hr class="divider" />
            <!-- QUERY TUNING BASICS  	============================ -->
            <section id="idocs_qt_basics">
              <div>
                <ol>
                  <li>
                    <p class="question"> what are the various steps involved while executing an SQL in Postgres? </p>
                    <p class="answer"> In PostgreSQL, there are primarily 4 steps 1. Parser It validates the syntax and creates a query tree from the query that is being written by the user. It will be handling the query-tree to Rewrite 2. Rewriter The query tree will be modified if needed so that query can be executed efficiently. Also if views are used they will be decomposed into underlying table references. 3. Planner The goal of the planner is to look at the query tree and figure out what data needs to be fetched and comes up with different plans and strategies that is best and fastest. For example, it will try to check if there are any indexes and see if there is any efficiency in using them vs pulling the data directly without using indexes etc. 4. Execute Run the Query </p>
                  </li>
                </ol>
              </div>
            </section>
            <hr class="divider" />
            <!-- QUERY TUNING ADVANCED ============================ -->
            <section id="idocs_qt_advanced">
            </section>
            <hr class="divider" />
            <!-- QUERY TUNING ADDITIONAL DETAILS  ============================ -->
            <section id="idocs_qt_add_details">
            </section>
            <hr class="divider" />
            <!-- Regular Expressions ============================ -->
            <section id="idocs_regex">
              <h3>Regular Expressions</h3>
              <p class="mb-5"> 
                Notes on Regular Expressions and its usage in Databases (POSTGRES)
              </p>
            </section>
            <!-- Regular Expression Basics   ============================ -->
            <section id="idocs_regex-basics">
              <h4>Basics</h4>
                <div>
                 <ol>
                    <li>
                      <p class="question"> 
                        What are the below <br/>
                        [abc]  ,  [^abc] , [a-z] , [A-Z] , [a-zA-Z] , [0-9] 
                      </p>
                      <p class="answer"> 
                        <ul>
                          <li> [abc]      →     a,b or C</li>
                          <li> [^abc]     →     any character except a, b, C</li>
                          <li> [a-z]      →     a to z</li>
                          <li> [A-Z]      →     A to Z</li>
                          <li> [a-zA-Z]   →     a to z , A to Z</li>
                          <li> [0-9]      →     0 to 9</li>
                        </ul>
                      </p>
                    </li>
                </ol>
                  </div>
            </section>
            <hr class="divider" />
            <!-- Quantifiers  ============================ -->
            <section id="idocs_quantifiers">
              <h4>Quantifiers</h4>
 
              <div>
                <ol>
                   <li>
                     <p class="question"> 
                       What are Quantifiers in Regular Expressions <br/>
                     </p>
                     <p class="answer"> 
                       <ul>
                         <li> [ ]?        →       Occurs 0 or 1 times</li>
                         <li> [ ]+        →       Occurs 1 or more times</li>
                         <li> [ ]*        →       Occurs 0 or more times</li>
                         <li>  [ ]{n}     →       Occurs n times</li>
                         <li>  [ ]{m,n}   →       Occurs at least m times but less than n times.</li>
                         <li>  [ ]{n,}    →       Occurs n or more times</li>
                       </ul>
                     </p>
                   </li>
                 </ol>
                 </div>
 
            </section>
            <hr class="divider" />
            <!-- Meta Characters ============================ -->
            <section id="idocs_meta_character">
              <h4>Meta Characters</h4>
 
              <div>
                <ol>
                   <li>
                     <p class="question"> 
                       What are Meta Characters in Regular Expressions <br/>
                     </p>
                     <p class="answer"> 
                       <ul>
                         <li> \d            →       [0-9]</li>
                         <li> \D            →       [^0-9]</li>
                         <li> \w            →       [a-zA-Z_0-9]</li>
                         <li>  \W           →       [^w]</li>
                         <li>  \s           →       white space characters "[\f\n\r\t\v]"</li>
                         <li>  \S           →       non white space characters</li>
                         <li>  "\p{Ll}"     →       [a-z]</li>
                         <li>  "\p{Lu}"     →       [A-Z]</li>
                       </ul>
                       Note: \ tells computer to treat special characters as search characters +,?,\,.,*  i.e. \+,\?,\\,\.,\* 
                     </p>
                   </li>
                 </ol>
                 </div>
 
 
            </section>
            <hr class="divider" />
            <!-- Special Characters ============================ -->
            <section id="idocs_special_chars">
              <h4>Special Characters</h4>
 
              <div>
                <ol>
                   <li>
                     <p class="question"> 
                       What are Special Characters in Regular Expressions <br/>
                     </p>
                     <p class="answer"> 
                       
                        "." (dot) which matches any single character except a newline. <br/>
                        "*" which matches zero or more occurrences of the preceding character or group. -- IS DEFAULT<br/>
                        "*?" which matches zero or more occurrences of the preceding character or group(non greedy). <br/>
                        "+" which matches one or more occurrences of the preceding character or group. -- IS DEFAULT<br/>
                        "+?" which matches one or more occurrences of the preceding character or group(non greedy). <br/>
                        "?" which matches zero or one occurrence of the preceding character or group. <br/>
                        "^" which matches the start of a string. <br/>
                        "$" which matches the end of a string. <br/>
                        "|" which separates alternatives.<br/>
                        "{" and "}" which are used to specify the number of occurrences of the preceding character or group. <br/>
                        "(" and ")" which are used to group characters or sub-expressions.<br/>
                        "[" and "]" which are used to specify a character class.<br/>
                        "" which is used to escape special characters.<br/>
                        "|" which separates alternatives.<br/>
                        \ is an escape character<br/>
                        <b>In Short</b> <br/>
                        start           : ^   <br/>
                        end             : $   <br/>
                        single char     : .   <br/>
                        zero or one     : *   <br/>
                        zero or many    : *   <br/>
                        one or many     : +   <br/>
                        OR operator     : |   <br/>
                        AND operator    : &   <br/>

                      </p>
                   </li>
                 </ol>
                 </div>
 
            </section>


            <hr class="divider" />
            <!-- Zero-Width Assertions ============================ -->
            <section id="idocs_zerowidth_assert">
              <h4>Zero-Width Assertions</h4>
 
              <div>
                <ol>
                   <li>
                     <p class="question"> 
                       What are Zero Width Assertions in Regular Expressions ?<br/>
                     </p>
                     <p class="answer"> 
                      It is a type of pattern in regular expressions that assert a condition without consuming any characters in the input string. 
                      They do not affect the final matched string, but influence the matching process. <br/>

                      <b>Positive Lookahead assertion:</b>  <span class="big">(?=)</span><br/>
                      Example: \w+(?=\d)<br/>
                      This regular expression matches a sequence of word characters followed by a digit. but the digit is not part of the final match.<br/>
                      Input String    : "abc123" <br/>
                      Matched String  : "abc" <br/> 

                      <b>Negative Lookahead assertion:</b>  <span class="big">(?!) </span><br/>
                      Example: \w+(?=!d)<br/>
                      This regular expression matches a sequence of word characters that are NOT followed by a digit. <br/>
                      Input String    : "abc123" <br/>
                      Matched String  : None <br/> 

                      
                      <br/>
                      
                      <b>Positive Lookbehind assertion:</b><span class="big">(?&lt;=) </span> <br/>
                      Example: (?&lt;=\d)px : <br/>
                      This regular expression matches "px" only if it is preceded by a digit. For example the following strings would match: 
                      "13px", "7px"<br/>
                      <b>Negative Lookbehind assertion:</b> <span class="big">(?&lt;!) </span><br/>
                      Example: (?&lt;!\d)px : <br/>
                      This regular expression matches "px" only if it is not preceded by a digit.  For example, the following strings would match: 
                      "px" , "abcpx"
                    </p>
                   </li>
                 </ol>
                 </div>
 
            </section>


            <hr class="divider" />
            <!-- Capturing Groups ============================ -->
            <section id="idocs_capturing_groups">
              <h4>Capturing Groups</h4>
 
              <div>
                <ol>
                   <li>
                     <p class="question"> 
                       What are Capturing Groups in Regular Expressions ?<br/>
                     </p>
                     <p class="answer"> 
                      Capture groups in regular expressions allow you to extract specific parts of the matched text. A capture group is defined by enclosing a portion of the pattern in parentheses <span class="big">(</span> and <span class="big">)</span>. 
                      You can then access the captured text using back references. 
                      In PostgreSQL, you can use the regexp_matches function to extract capture groups. The function returns an array of text arrays, where each text array represents a capture group.
                      Here's an example of how to use capture groups with the regexp_matches function in PostgreSQL: <br/>

                     

                      <pre>
                        <code class="hljs" data-language="sql">SELECT regexp_matches('10.20.30.40', '(\d+)\.(\d+)\.(\d+)\.(\d+)');
                        This will return the following output:

                         Output  
                         regexp_matches
                         ----------------
                          {{10,20,30,40}}
                         (1 row)

                        </code>
                      </pre>
                      
                      As you can see, the regexp_matches function has returned an array of text arrays, where each text array contains a single captured group. 
                      The pattern (\d+)\.(\d+)\.(\d+)\.(\d+) has four capture groups, each capturing a single digit separated by a period. <br/>

                      In PostgreSQL, if a query returns an array data type, you can refer to each element of the array as a separate column using the <span class="big">unnest  </span> function. 
                      The <span class="big">unnest  </span>function takes an array as its input and returns a row for each element in the array.<br/>
                      Here's an example of how to use the unnest function to refer to each element of an array as a separate column:

                      <pre>
                        <code class="hljs" data-language="sql">
                      WITH data AS (
                          SELECT regexp_matches('10.20.30.40', '(\d+)\.(\d+)\.(\d+)\.(\d+)') as ip_parts
                      )
                      SELECT unnest(ip_parts) as ip_part FROM data;


                      ip_part
                      ---------
                       10
                       20
                       30
                       40
                      (4 rows)

                      
                      WITH data AS (
                        SELECT regexp_matches('10.20.30.40', '(\d+)\.(\d+)\.(\d+)\.(\d+)') as ip_parts
                        )
                        SELECT ip_parts[1] as first_part, ip_parts[2] as second_part, ip_parts[3] as third_part, ip_parts[4] as fourth_part
                        FROM data, unnest(ip_parts) with ordinality;


                        This will return the following output:

                        first_part | second_part | third_part | fourth_part
                        -----------+------------+-----------+-----------
                        10        | 20         | 30        | 40
                        (1 row)
                    </code>
                  </pre>
                  <b>Non Capturing Groups:</b> <br/>
                  In regular expressions, a non-capturing group is a group that is used for grouping purposes only, but its contents are not captured and can't be accessed separately. 
                  The syntax for a non-capturing group is <span class="big">(?:pattern)</span>, where pattern is the regular expression pattern that should be grouped.<br/>
                  For example, let's say you want to extract the year from a string that contains a date. The date could be in the format "dd-mm-yyyy" or "dd/mm/yyyy". 
                  To extract the year, you could use a non-capturing group to match the separator (either - or /), without capturing it:

                  <pre>
                    <code class="hljs" data-language="sql">
                        WITH sample_data AS (
                          SELECT '01-01-2023'::text AS date_string
                        ), extracted_data AS (
                          SELECT matches as date_values, matches[1] as month ,matches[2] as day ,matches[3] as year
                          FROM (
                            SELECT regexp_matches(date_string, '(\d{2})(?:[-/])(\d{2})(?:[-/])(\d{4})') as matches
                            FROM sample_data
                          ) matches
                        )
                        SELECT *
                        FROM extracted_data;

                        This will return the following output:
                        date_values  |	month |	day |	year
                        ---------------------------------
                        {01,01,2023} |	01    |	01  |	2023

                    </code>
                  </pre>

                  In this example, the non-capturing group (?:[-/]) matches either - or / in the date string, but it doesn't capture them. 
                  The capturing groups (\d{2}) and (\d{4}) capture the day, month and year values, which are then returned in the query result.<br/><br/>

                  <b>Another Example:</b>
                  Regular Expression for Phone Numbers <br/>
                   <span class="big"> '(?:(?&lt;intlcode&gt;\+1)[ -])?\(?(?&lt;areacode&gt;\d{3})\)?[ -]?(?&lt;pnum1&gt;\d{3})[ -]?(?&lt;pnum2&gt;\d{4})'</span> <br/>
                  <span class="big"> ?:</span> is for un captured group <br/>
                  <span class="big"> ?&lt;intlcode&gt; , ?&lt;areacode&gt; , ?&lt;pnum1&gt; , ?&lt;pnum2&gt; </span> is to give names for captured groups. Here intlcode, areacode, pnum1, pnum2 are the names of the groups <br/>


                  <pre>
                    <code class="hljs" data-language="sql">
  
                  WITH sample_data AS (
                      SELECT '+1 (123) 456-7890'::text AS phone_number
                    ), extracted_data AS (
                      SELECT matches, concat(
                        coalesce(matches[1], ''),
                        matches[2],
                        matches[3],
                        matches[4]
                      ) as custom_format_number
                      FROM (
                        SELECT regexp_matches(phone_number, '(?:(\+1)[ -])?\(?(\d{3})\)?[ -]?(\d{3})[ -]?(\d{4})' ,'g') as matches
                        FROM sample_data
                      ) matches
                    )
                    SELECT matches, custom_format_number
                    FROM extracted_data

                    This will return the following output:
                    matches           |	custom_format_number |
                    -------------------------------------------
                    {+1,123,456,7890} |	+11234567890

                    
                  </code>
                </pre>

                    </p>
                   </li>
                 </ol>
                 </div>
 
            </section>


            <hr class="divider" />
            <!-- RegexFunction ============================ -->
            <section id="idocs_regex_matches">
              <h4>Regexp_matches</h4>
 
              <div>
                <ol>
                   <li>
                     <p class="question"> 
                       Deep dive into regexp_matches function<br/>
                     </p>
                     <p class="answer"> 
                      The regexp_matches function in PostgreSQL is used to match a regular expression pattern against a string and return the matched substrings as a set of text values. The function has the following syntax:
                     

                      <pre>
                        <code class="hljs" data-language="sql">regexp_matches(string text, pattern text [, flags text])
                        </code>
                      </pre>
                      where <u>string</u> is the input string to be searched, <u>pattern</u> is the regular expression pattern to be matched, and flags is an optional argument that specifies any flags to modify the behavior of the match. 
                      The function returns a set of text values, with one value for each match found in the input string. <br/>
                      The <u>regexp_matches</u> function uses the POSIX extended regular expression syntax, which provides a wide range of features for matching text patterns. For example, you can use the function to match patterns such as email addresses, 
                      dates, and phone numbers, or to extract information from structured text such as HTML or XML. <br/>                     
                      The <u>flags</u> argument is optional, and it can be used to modify the behavior of the match. Some of the commonly used flags are:<br/>

                      <b>g: </b> Global match (multiple matches across the string)<br/>
                      <b> i: </b>Case-insensitive match<br/>
                      <b>m: </b>Multiline match, "^" and "$" match start/end of lines (not just start/end of string)<br/>
                      <b>c: </b>Case-sensitive match<br/>
                      <b>p: </b>Partial newline-sensitive match<br/>
                      Note that you can use multiple flags together, by concatenating them. For example, to perform a case-insensitive, global search, you would use the flags gi. <br/><br/>


                      <p>Here is an explanation of each flag supported by <code>regexp_matches</code> in PostgreSQL:</p>
                      <ul><li><code>g</code> 
                      (Global): Specifies that the match should return multiple matches across the entire input string, instead of just the first match.
                     </li></ul>
                      <p>Example: <code>SELECT regexp_matches('abcabcabc', '[a-z]+', 'g');</code> will return <code>{abc,abc,abc}</code>.</p>
                      <ul><li><code>i</code> 
                      (Case-Insensitive): Makes the match case-insensitive, so it will match upper-case and lower-case letters without differentiation.</li></ul>
                      <p>Example: <code>SELECT regexp_matches('ABCabc', '[a-z]+', 'i');</code> will return <code>{ABC,abc}</code>.</p>
                      <ul><li><code>m</code> (Multiline): Specifies that the "^" and "$" symbols in the pattern should match the start and end of lines (not just the start and end of the input string).</li></ul>
                      <p>Example: <code>SELECT regexp_matches('line1\nline2', '^[a-z]+', 'm');</code> will return <code>{line1, line2}</code>.</p>
                      <ul><li><code>c</code> (Case-Sensitive): Makes the match case-sensitive, so it will differentiate between upper-case and lower-case letters. This is the default behavior of <code>regexp_matches</code>.</li></ul>
                      <p>Example: <code>SELECT regexp_matches('ABCabc', '[a-z]+', 'c');</code> will return <code>{abc}</code>.</p>
                      <ul><li><code>p</code> (Partial newline-sensitive): Makes the "^" and "$" symbols in the pattern match the start and end of the input string, including any partial line at the end of the input string.</li></ul>
                      <p>Example: <code>SELECT regexp_matches('line1\nline2\n', '^[a-z]+$', 'mp');</code> will return <code>{line2}</code>.</p>
                      <p>It's possible to use multiple flags together, by concatenating them. For example, to perform a case-insensitive, global search, you would use the flags <code>gi</code>.</p>

                      Note: PostgreSQL does not have the capability to name capture groups in regular expressions when using the regexp_matches function. 
                      In regexp_matches, the matched substrings are identified only by their position within the matched pattern. <br/>

                     </p>
                   </li>
                 </ol>
                 </div>
 
            </section>


            <hr class="divider" />

            <!-- RegEx Examples ============================ -->
            <section id="idocs_regex_examples">
            <h4>Examples</h4>
          
            <div>
              <ol>
                 <li>
                   <p class="question"> 
                     How to Test Regular Expressions in Postgres? <br/>
                   </p>
                   Here 'g' stands to pull all the matches
                   <p class="answer"> 
                    <pre>
                      <code class="hljs" data-language="sql">select regexp_matches(E'search-string', 'regular-expression'  , <b class="high-light">'g' </b>) as col   </code>
                    </pre>
                  
                    It will pull only the first match and stops executing. 
                   <pre>
                    <code class="hljs" data-language="sql">select regexp_matches(E'search-string', 'regular-expression' ) as col </code>
                   </pre>
                 
                    </p>
                 </li>



                 <li>
                  <p class="question"> 
                    In the regular expression if we specify '()' is what is going display? <br/>
                  </p>
                  It will return {com} only
                  <p class="answer"> 

                    <pre>
                      <code class="hljs" data-language="sql">select regexp_matches(E'abc@abc.com, bbc@bbc.com', '[a-z]+[@][a-z]+[\.]<b class="high-light">(</b>[a-z]+<b class="high-light">)</b>'  , 'g') as col </code>
                     </pre>
    
                  It will return {abc@abc.com} , {bbc@bbc.com}.
                 
                  <pre>
                    <code class="hljs" data-language="sql"> SELECT regexp_matches(E'abc@abc.com, bbc@bbc.com', '[a-z]+[@][a-z]+[\.]([a-z]+)'  , 'g') as col ;
                    </code>
                  </pre>                

                  </pre>
                </li>

                <li>
                  <p class="question"> 
                   What are other ways of executing Regular Expressions in PostGreSQL? <br/>
                  </p>

                  <p class="answer"> 
                   <pre>
                     <code class="hljs" data-language="sql">SELECT regexp_matches(E'abc@abc.com, bbc@bbc.com', '[a-z]+[@][a-z]+[\.][a-z]+'  , 'g') as col <br/>SELECT column from table where column ~'regular-expression'</code>
                   </pre>
                 
                  <pre>
                   <code class="hljs" data-language="sql">SELECT substring(column FROM 'regular-expression') from TABLE</code>
                 </pre>
                   </p>
                </li>


               </ol>
               </div>


          </section>
          <hr class="divider" />
            <!-- FAQ ============================ -->
            <section id="idocs_faq">
              <h2>FAQ</h2>
              <p class="text-4"> A FAQ is a list of frequently asked questions (FAQs) and answers on a particular topic. </p>
            </section>
            <hr class="divider" />
            <!-- Source & Credits ============================ -->
            <section id="idocs_source_credits">
              <h2>Source & Credits</h2>
            </section>
            <hr class="divider" />
            <!-- Support ============================ -->
            <section id="idocs_support">
              <h2>Support</h2>
              <p> We are located in GMT +5:30 time zone and we answer all questions within 12-24 hours in weekdays. In some rare cases the waiting time can be to 48 hours. (except holiday seasons which might take longer). </p>
              <div class="alert alert-warning mb-4">
                <span class="badge badge-danger text-uppercase">Note:</span> While we aim to provide the best support possible, please keep in mind that it only extends to verified buyers and only to issues related to our template like bugs and errors. Custom modifications or third party module implementations are not included.
              </div>
              <div class="alert alert-success"> Please Add your Review (Opinion) for Our template. It would be a great support for us. <br /> Go to your <strong>Themeforest Profile</strong> > <strong>Downloads Tab</strong> > & then You can Rate & Review for our template. <br /> Thank You. </div>
            </section>
            <hr class="divider" />
            <!-- More Templates 		============================ -->
            <section id="idocs_templates">
              <h2>More Templates</h2>
            </section>
            <hr class="divider" />
            <!-- Changelog ============================ -->
            <section id="idocs_changelog">
              <h2>Changelog</h2>
              <p class="text-4"> See what's new added, changed, fixed, improved or updated in the latest versions. </p>
              <hr class="divider" />
              <h3 id="v1-0"> Version 1.0 <small class="text-muted">(3 Jan, 2023)</small>
              </h3>
              <p>Initial Release</p>
            </section>
          </div>
        </div>
      </div> <!-- Content end -->
    </div> <!-- SEARCHABLE CONTENT END -->
      
      <!-- Footer ============================ -->
      <footer id="footer" class="section bg-dark footer-text-light">
        <div class="container">
          <p class="text-center"> Copyright &copy; 2023 <a rel='noopener' href="#">Jai Saibaba</a>. All Rights Reserved. </p>
          <p class="text-2 text-center mb-0"> Design &amp; Develop by  <a rel='noopener' class="btn-link" target="_blank" href="#">Jai Saibaba</a>. </p>
        </div>
      </footer>
      <!-- Footer end -->
    </div>
    <!-- Document Wrapper end -->
    <!-- Back To Top -->
    <a id="back-to-top" data-toggle="tooltip" title="Back to Top" href="javascript:void(0)">
      <i class="fa fa-chevron-up"></i>
    </a>
    <!-- JavaScript ============================ -->
    <script src="/assets/vendor/jquery/jquery.min.js"></script>
    <script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
    <!-- Highlight JS -->
    <script src="/assets/vendor/highlight.js/highlight.min.js"></script>
    <!-- Easing -->
    <script src="/assets/vendor/jquery.easing/jquery.easing.min.js"></script>
    <!-- Magnific Popup -->
    <script src="/assets/vendor/magnific-popup/jquery.magnific-popup.min.js"></script>
    <!-- Custom Script -->
    <script src="/assets/js/theme.js"></script>
    <!--Syntax Highlight-->



    
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <script>
      var searchInput = document.querySelector("#search-input");
      
      searchInput.addEventListener("keyup", function () {
          var searchTerm = this.value.toLowerCase();
          console.log('values are ', searchTerm);
          // var searchResults = document.querySelectorAll("[textContent*='" + searchTerm + "']");
      
          var relValue = "no-val"
          $('#search-content').find("*").each(function(){
              var search = $(this).text().toLocaleLowerCase();
              if(search.indexOf(searchTerm) > -1){
               if( $(this).is("[nodisplay]")) {
      
               }else{
                  $(this).show();
                 // $(this).addClass("highlight");
                  relValue = $(this).attr("map");
                  console.log("the attrvalue is " ,relValue);
                  //$("#"+idValue).show();
                  $('[map='+ relValue +']').show();
               }  
                 // $(this).siblings('p').siblings('a').show();
                 // console.log($(this).siblings('a'));
              }
              else{
                // if(this.tagName == 'H2') {
              if( $(this).is("[display]")) {
                 // display="true"
                  $(this).show();
                 // $(this).addClass("highlight");
                  //$(this).siblings('a').show();
                  console.log($(this).get(0));
                  console.log('tag-name' , this.tagName);
                 //}else if (relValue !== 'no-val'){
                 // $('[rel='+ relValue +']').show();
                 }else {
                  $(this).hide();
                  $('[map='+ relValue +']').show();
                  //$(this).siblings('a').hide();
                 }
                 
                                    
              }
      
             
          });
        
      });
   
     
      
   </script>


<!-- <script>
   var searchInput = document.querySelector("#search-input");
   
   searchInput.addEventListener("keyup", function () {
       var searchTerm = this.value.toLowerCase();
       console.log('values are ', searchTerm);
       // var searchResults = document.querySelectorAll("[textContent*='" + searchTerm + "']");
       $('#search-content').find("*").each(function(){
           var search = $(this).text().toLocaleLowerCase();
           if(search.indexOf(searchTerm) > -1){
               $(this).show();
           }
           else{
             // if(this.tagName == 'H2') {
           if( $(this).is("[display]")) {
              // display="true"
               $(this).show();
               console.log($(this).get(0));
               console.log('tag-name' , this.tagName);
              }else{
               $(this).hide();
              }
              
                                 
           }
   
       });
   
   });

  
const $searchElement = $("#searching");
let value = "";

$(document).on("keyup", function(event) {
  if (event.key !== "Enter") {
    value += event.key;
  } else {
    if (value === "show") {
      $searchElement.show();
    } else if (value === "hide") {
      $searchElement.hide();
    }

    value = "";
  }
  console.log(value);
});



</script> -->

  </body>
</html>